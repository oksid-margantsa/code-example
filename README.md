# code-example
Этот репозиторий содержит примеры кода, разработанные в рамках выполненных мною лабораторных работ.
Все работы написаны в рамках стандарта С++14
# COMMON
Хранит структуры и функции, используемые сразу в нескольких проектах

# S1 Списки
Программа считывает последовательности чисел из стандартного ввода.
Каждая строка содержит название последовательности (одно слово латиницей) и целые положительные числа.
•	Количество чисел в последовательностях может различаться.
•	Название состоит только из латинских букв и является одним словом.
•	Признак конца ввода — EOF:
o	Linux: Ctrl + D
o	Windows: Ctrl + Z, затем Enter
Программа должна вывести:
1.	Список названий всех введённых последовательностей в одной строке.
2.	Числовые последовательности, составленные следующим образом:
o	Сначала идут первые элементы всех последовательностей.
o	Затем вторые элементы (если есть).
o	И так далее, пока числа не закончатся во всех последовательностях.
o	Числа каждой последовательности включаются в результат ровно один раз.
o	Каждая последовательность выводится на отдельной строке.
3.	Список сумм значений составленных последовательностей, если такой расчёт возможен.
Входные данные:
first 1 1 1
second 2 2 2 2                                                         
third 
fourth 4 4
Ожидаемый вывод:
first second third fourth  
1 2 4  
1 2 4  
1 2  
2  
7 7 3 2  
Обработка ошибок
1.	Если ввод не содержит последовательностей, программа должна вывести 0.
2.	Если расчёт суммы невозможен, программа должна завершиться с сообщением об ошибке и кодом возврата 1.
3.	В остальных случаях программа завершает работу с кодом возврата 0.
Реализация хранения данных
Для хранения чисел был реализован шаблон класса однонаправленного списка и итераторы для его обхода
Интерфейс класса должен быть безопасным относительно исключений.

# S2 Стек и очередь
Арифметические выражения содержатся в файле, имя которого задано параметром командной строки, по одному выражению на каждой строке.
• Элементы выражения гарантировано разделены ровно одним пробелом (при этом выражения
могут быть неверными с точки зрения математики). Пример входного файла:
( 1 + 2 ) * ( 3 - 4 )
1 + 3
( 10 / ( 2 + 3 ) % 4 )
4 * 7 - 3
• Пустые строки в файле пропускаются
• Если параметр командной строки filename не задан, выражения читаются со стандартного ввода. Признаком конца ввода является EOF(на Linux: Ctrl + D | на Windows Ctrl + Z затем Enter)
• Если арифметические выражения верны, результатом работы программы являются результаты
вычисления выражений выведенные в обратном порядке (относительно порядка выражений) в
одну строку, разделённые ровно одним пробелом
• В арифмитических выражениях используются только бинарные операции: + — сложение, - —
вычитание, * — умножение, / — деление, % — остаток от деления
• В случае ошибки во время вычислений (например, операнд не является числом или арифметическое выражение неверно) программа должна завершаться с ненулевым кодом возврата и
сообщением об ошибке
3. Работа должна быть выполнена в виде 1-го исполняемого файла, принимающего параметры следующим образом:
$ ./lab {filename}
filename представляет собой опциональной параметр. Поведение программы меняется в зависимости
от того передан он или нет
4.	Для реализации были разработаны интерфейсы стека и очереди на основе однонаправленного списка, реализованного в рамках работы над проектом S1

# S4 Бинарное дерево поиска
Реализован шаблон класса BinarySearchTree и соответствующие итераторы
Реализуемая программа должна считывать данные словарей из файла и выполнять команды, принимаемые от пользователя со стандартного ввода.
• Каждая строка содержит ровно одну команду. Должны поддерживаться следующие команды:
print <dataset>
complement <newdataset> <dataset-1> <dataset-2>
intersect <newdataset> <dataset-1> <dataset-2>
union <newdataset> <dataset-1> <dataset-2>
• Команда print <dataset> выводит данные словаря с соответствующем именем в порядке сортировки ключей. Например, для second должна быть напечатана строка
second 1 name 2 keyboard 4 mouse
Если словарь пуст, то команда должна вывести сообщение <EMPTY>
• Команда complement <newdataset> <dataset-1> <dataset-2> строит словарь с новым именем
как вычитание множеств двух других словарей. Например, для команд:
complement third second first
print third
Команда intersect <newdataset> <dataset-1> <dataset-2> строит словарь с новыми именем
как пересечение множеств двух других словарей. Например, для команд:
intersect fourth first second
print fourth
Должен быть результат:
fourth 1 name 2 surname
Если ключи дублируются, в качестве значения выбираются данные из левого операнда, т. е.
для команд:
intersect yafourth second first
print yafourth
Должен быть результат:
yafourth 1 name 2 keyboard
• Команда union <newdataset> <dataset-1> <dataset-2> строит словарь с новым именем как
объединение множеств двух других словарей. Например, для команд:
union fifth first second
print fifth
Должен быть результат:
fifth 1 name 2 surname 4 mouse
Если ключи дублируются, в качестве значения выбираются данные из левого операнда, т. е.
для команд:
union yafifth second first
print yafifth
Должен быть результат:
yafifth 1 name 2 keyboard 4 mouse
• Если команда по каким-то причинам некорректна, то команда должна вывести сообщение
<INVALID COMMAND>
• Других команд реализовывать не требуется
• Признаком конца ввода команд является EOF (на Linux: Ctrl + D | на Windows Ctrl + Z затем
Enter)
Работа должна быть выполнена в виде 1-го исполняемого файла, принимающего параметры следующим образом:
$ ./lab filename
filename представляет собой обязательный параметр. Поведение программы меняется в зависимости
от того передан он или нет. Если параметр filename не задан, программа должна завершаться с
ненулевым кодом возврата и сообщением об ошибке

# F0 Алгоритм поиска кратчайших путей для заданной вершины
Реализация алгоритма Дейкстры, была реализована следующая система команд
help – вывод всех доступных команд с параметрами
create < graph > < graphname > - создание пустого графа с названием graphname
add < vertex > < name > – создание вершины графа с названием name
add < edge > < first_node, second_node, weight > - создание ребра между вершинами first_node и second_node с весом weight; если first_node == second_node или weight <= 0 обрабатывается ошибка
delete < vertex > < name > - удаление вершины name, если существуют ребра, ведущие к этой вершине, они также удаляются; если вершины name не существует, обрабатывается ошибка
delete < edge > < first_node, second_node > - удаление ребра между вершинами first_node и second_node, если его не существует, то обрабатывается ошибка
capacity < graphname > - вывод количества вершин в графе graphname
weightTable < graphname > - вывод весовой таблицы графа graphname, если ребра между вершинами не существует, то в таблице выводится - , если ребро есть, то выводится его вес
print < shortest path > < name > - вывод кратчайших путей от вершины name до остальных.
print < distance > < name > - вывод длин кратчайших путей от вершины name до остальных.
open < filename > — открытие файла для чтения с заданным названием
save < filename > — открытие файла для вывода с заданным названием, в файл сохраняется весовая таблица активного графа
list — вывод списка графов
graphname — выводит имя графа, над которым ведется работа
delete < graphname > - удаление графа graphname
clear - удаление всех вершин графа, над которым ведется работа
Структура графа основана на списке (S1) и бинарном дереве поиска (S4).

# F1 Алгоритм поиска кратчайших путей для заданной вершины
Реализация той же системы команд, что и F0, однако использованы контейнеры стандартной библиотеки.


