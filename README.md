# code-example

Этот репозиторий содержит примеры кода, разработанные в рамках выполненных мною лабораторных работ.  
Все работы написаны в рамках стандарта **C++14**.

---

## COMMON

Хранит структуры и функции, которые используются сразу в нескольких проектах.

---

## S1 — Списки

Программа считывает последовательности чисел из стандартного ввода.  
Каждая строка содержит название последовательности (одно слово латиницей) и целые положительные числа.

- Количество чисел в последовательностях может различаться.  
- Название состоит только из латинских букв и является одним словом.  
- Признак конца ввода — EOF:  
  - Linux: `Ctrl + D`  
  - Windows: `Ctrl + Z`, затем `Enter`

**Программа должна вывести:**

1. Список названий всех введённых последовательностей в одной строке.  
2. Числовые последовательности, составленные следующим образом:
   - Сначала идут первые элементы всех последовательностей.
   - Затем вторые элементы (если есть), и так далее.
   - Числа каждой последовательности включаются в результат один раз.
   - Каждая последовательность выводится на отдельной строке.
3. Список сумм значений составленных последовательностей, если расчёт возможен.

**Пример входных данных:**
first 1 1 1
second 2 2 2 2
third
fourth 4 4

**Ожидаемый вывод:**
first second third fourth
1 2 4
1 2 4
1 2
2
7 7 3 2

**Обработка ошибок:**

- Если ввод не содержит последовательностей — программа выводит `0`.
- Если расчёт суммы невозможен — программа завершает работу с кодом возврата `1` и сообщением об ошибке.
- В остальных случаях — код возврата `0`.

**Реализация хранения данных:**

Для хранения чисел реализован шаблон класса однонаправленного списка и итераторы.  
Интерфейс должен быть безопасным относительно исключений.

---

## S2 — Стек и очередь

Программа обрабатывает арифметические выражения из файла (или stdin) и вычисляет их.

- Выражения содержатся в файле, имя которого передаётся через аргумент командной строки.  
- Каждый элемент выражения разделён ровно одним пробелом.  
- Пример:

( 1 + 2 ) * ( 3 - 4 )
1 + 3
( 10 / ( 2 + 3 ) % 4 )
4 * 7 - 3
- Пустые строки пропускаются.  
- Если параметр не задан, данные читаются из stdin.  
- Признак конца ввода — EOF.

**Требования:**

- Поддерживаются только бинарные операции: `+`, `-`, `*`, `/`, `%`
- Результаты выводятся в **обратном порядке**, в одну строку, через пробел.
- В случае ошибки — сообщение об ошибке и ненулевой код возврата.

**Запуск:**
$ ./lab {filename}

Если файл не указан — данные читаются из stdin.  
Для реализации использованы стек и очередь на базе однонаправленного списка (`S1`).

---

## S4 — Бинарное дерево поиска

Реализован шаблон `BinarySearchTree` и итераторы.  
Программа считывает данные словарей из файла и выполняет команды из stdin.

**Поддерживаемые команды:**

print <dataset> complement <newdataset> <dataset-1> <dataset-2> intersect <newdataset> <dataset-1> <dataset-2> union <newdataset> <dataset-1> <dataset-2>

**Пример:**
print second
-> second 1 name 2 keyboard 4 mouse

complement third second first
print third
-> third ...

intersect fourth first second
print fourth
-> fourth 1 name 2 surname

union fifth first second
print fifth
-> fifth 1 name 2 surname 4 mouse

- При дублировании ключей при `intersect` или `union` — приоритет у **левой** последовательности.  
- Некорректная команда → `<INVALID COMMAND>`  
- Конец ввода — `EOF`  

**Запуск:**
$ ./lab filename

`filename` — обязательный аргумент.  
Если не задан — ошибка и завершение с ненулевым кодом.

---

## F0 - Алгоритм поиска кратчайших путей (Дейкстра)
Реализован алгоритм Дейкстры с поддержкой следующих команд:

## Основные команды:
- help – вывод всех доступных команд и их параметров.
- create graph <graphname> – создание пустого графа с именем graphname.
- add vertex <name> – добавление вершины name в граф.
- add edge <first_node> <second_node> <weight> – создание ребра между вершинами first_node и second_node с весом weight.
  - Если first_node == second_node или weight <= 0, выводится ошибка.
- delete vertex <name> – удаление вершины name (все связанные с ней рёбра тоже удаляются).
  - Если вершины не существует, выводится ошибка.
- delete edge <first_node> <second_node> – удаление ребра между first_node и second_node.
  - Если ребро не существует, выводится ошибка.

## Работа с графом:
- capacity <graphname> – вывод количества вершин в графе graphname.
- weightTable <graphname> – вывод весовой таблицы графа.
  - Если ребра нет, выводится "-", если есть — его вес.

## Поиск кратчайших путей:
- print shortest path <name> – вывод кратчайших путей от вершины name до остальных.
- print distance <name> – вывод длин кратчайших путей от вершины name.

## Файловые операции:
- open <filename> – открытие файла filename для чтения.
- save <filename> – сохранение весовой таблицы активного графа в файл filename.

## Дополнительные команды:
- list – вывод списка всех графов.
- graphname – вывод имени активного графа.
- delete <graphname> – удаление графа graphname.
- clear – удаление всех вершин текущего графа.

Структура графа основана на однонаправленном списке (S1) и бинарном дереве поиска (S4).

---

## F1 - Поиск кратчайших путей (стандартные контейнеры)
Аналогичная реализация алгоритма Дейкстры, но с использованием контейнеров стандартной библиотеки (std::map, std::vector, std::priority_queue и др.).

